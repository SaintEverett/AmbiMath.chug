//-------------------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-------------------------------------------------------------------------------------
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-------------------------------------------------------------------------------------
// happy chucking & chugging!
//-------------------------------------------------------------------------------------
// hello, this is AmbiMath by Everett M. Carpenter.
// you may need to configure some include paths regarding header files
// if you're looking to build this chugin or make your own flavor (which is encouraged)
//-------------------------------------------------------------------------------------

// include chuck headers
#include "chugin.h"

// general includes
#include "AmbiMath.h"

// declaration of chugin constructor
CK_DLL_CTOR(ambimath_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(ambimath_dtor);

CK_DLL_MFUN(all_CoordinatePolar);
CK_DLL_MFUN(all_CoordinateCartesian);
CK_DLL_MFUN(x_CoordinatePolar);
CK_DLL_MFUN(x_CoordinateCartesian);
CK_DLL_MFUN(y_CoordinatePolar);
CK_DLL_MFUN(y_CoordinateCartesian);
CK_DLL_MFUN(z_CoordinatePolar);
CK_DLL_MFUN(z_CoordinateCartesian);
CK_DLL_MFUN(all_CoordinatePolar);
CK_DLL_MFUN(all_CoordinateCartesian);

// example of getter/setter
CK_DLL_MFUN(ambimath_setParam);
CK_DLL_MFUN(ambimath_getParam);

// for chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(ambimath_tick);

// this is a special offset reserved for chugin internal data
t_CKINT ambimath_data_offset = 0;
int mode = 0;
double coordinates[64];

/*
// array of coordinate function pointers
typedef double (*func_storage) ();
func_storage funcs[] = {w,y,z,x,v,t,r,s,u,q,o,m,k,l,n,p,hoa4_0,hoa4_1,hoa4_2,hoa4_3,hoa4_4,hoa4_5,hoa4_6,hoa4_7,hoa4_8}; // in spherical order
*/

//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class AmbiMath
{
public:
    // constructor
    AmbiMath(t_CKFLOAT fs)
    {
        ;
    }

private:
};


//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO(AmbiMath)
{
    // the version string of this chugin, e.g., "v1.2.1"
    QUERY->setinfo(QUERY, CHUGIN_INFO_CHUGIN_VERSION, "v0.0.1 - 'Lanquidity'");
    // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
    QUERY->setinfo(QUERY, CHUGIN_INFO_AUTHORS, "Everett M. Carpenter");
    // text description of this chugin; what is it? what does it do? who is it for?
    QUERY->setinfo(QUERY, CHUGIN_INFO_DESCRIPTION, "AmbiMath calculates cartesian coordinates given an elevation angle and directional angle. As of v0.0.1 'Landquidity', coordinates up to the third order are available.");
    // (optional) URL of the homepage for this chugin
    QUERY->setinfo(QUERY, CHUGIN_INFO_URL, "");
    // (optional) contact email
    QUERY->setinfo(QUERY, CHUGIN_INFO_EMAIL, "");
}

//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY(AmbiMath)
{
    // generally, don't change this...
    QUERY->setname(QUERY, "AmbiMath");

    // ------------------------------------------------------------------------
    // begin class definition(s); will be compiled, verified,
    // and added to the chuck host type system for use
    // ------------------------------------------------------------------------
    // NOTE to create a non-UGen class, change the second argument
    // to extend a different ChucK class (e.g., "Object")
    QUERY->begin_class(QUERY, "AmbiMath", "Object");
    QUERY->doc_class(QUERY, "Math required for Ambisonics");

    // register default constructor
    QUERY->add_ctor(QUERY, ambimath_ctor);
    // NOTE constructors can be overloaded like any other functions,
    // each overloaded constructor begins with `QUERY->add_ctor()`
    // followed by a sequence of `QUERY->add_arg()`

    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, ambimath_dtor);

    // for UGens only: add tick function
    // NOTE a non-UGen class should remove or comment out this next line
    // QUERY->add_ugen_func( QUERY, ambimath_tick, NULL, 1, 1 );
    // NOTE: if this is to be a UGen with more than 1 channel,
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function usinfg CK_DLL_TICKF  
    // function definition

    // x coordinate(polar)
    QUERY->add_mfun(QUERY, x_CoordinatePolar, "float", "x");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian X coordinate given elevation and direction angles");

    // x coordinate(cartesian)
    QUERY->add_mfun(QUERY, x_CoordinateCartesian, "float", "x");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian X coordinate given x,y,z");

    // y coodinate(polar)
    QUERY->add_mfun(QUERY, y_CoordinatePolar, "float", "y");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian Y coordinate given elevation and direction angles");

    // y coordinate(cartesian)
    QUERY->add_mfun(QUERY, y_CoordinateCartesian, "float", "y");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian Y coordinate given x,y,z");

    // z coordinate(polar)
    QUERY->add_mfun(QUERY, z_CoordinatePolar, "float", "z");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian Z coordinate given elevation and direction angles");

    // z coordinate(cartesian)
    QUERY->add_mfun(QUERY, z_CoordinateCartesian, "float", "z");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian Z coordinate given x,y,z");

    // all coordinates
    QUERY->add_mfun(QUERY, all_CoordinatePolar, "float[]", "all");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->add_arg(QUERY, "int", "order");
    QUERY->doc_func(QUERY, "Computes all coordinates of a given order and fills an array of the corresponding size. Order of coordinates is w,y,z,x,v,t,r,s,u,q,o,m,k,l,n,p,hoa4_0,hoa4_1,hoa4_2,hoa4_3,hoa4_4,hoa4_5,hoa4_6,hoa4_7,hoa4_8.");

    // all coordinates
    QUERY->add_mfun(QUERY, all_CoordinateCartesian, "float[]", "all");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->add_arg(QUERY, "int", "order");
    QUERY->doc_func(QUERY, "Computes all coordinates of a given order and returns an array of the corresponding size. Order of coordinates is w,y,z,x,v,t,r,s,u,q,o,m,k,l,n,p,hoa4_0,hoa4_1,hoa4_2,hoa4_3,hoa4_4,hoa4_5,hoa4_6,hoa4_7,hoa4_8.");

    // create and set w constant
    QUERY->add_svar(QUERY, "float", "w", TRUE, &w_constant);
    QUERY->doc_var(QUERY, "W constant used in SN3D Ambisonics");

    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    ambimath_data_offset = QUERY->add_mvar(QUERY, "int", "@am_data", false);

    // ------------------------------------------------------------------------
    // end the class definition
    // IMPORTANT: this MUST be called to each class definition!
    // ------------------------------------------------------------------------
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the default constructor
CK_DLL_CTOR(ambimath_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, ambimath_data_offset) = 0;

    // instantiate our internal c++ class representation
    AmbiMath* am_obj = new AmbiMath(API->vm->srate(VM));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, ambimath_data_offset) = (t_CKINT)am_obj;
}


// implementation for the destructor
CK_DLL_DTOR(ambimath_dtor)
{
    // get our c++ class pointer
    AmbiMath* am_obj = (AmbiMath*)OBJ_MEMBER_INT(SELF, ambimath_data_offset);
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE(am_obj);
    // set the data field to 0
    OBJ_MEMBER_INT(SELF, ambimath_data_offset) = 0;
}

CK_DLL_MFUN(all_CoordinatePolar)
{
    // get our c++ class pointer
    AmbiMath* am_obj = (AmbiMath*)OBJ_MEMBER_INT(SELF, ambimath_data_offset);
    t_CKFLOAT direction = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT elevation = GET_NEXT_FLOAT(ARGS);
    t_CKINT order = GET_NEXT_INT(ARGS);
    int degree = pow((order + 1), 2);
    all(direction, elevation, coordinates, order);
    // Create a float[] array
    Chuck_DL_Api::Object returnarray = API->object->create(SHRED, API->type->lookup(VM, "float[]"), false);
    Chuck_ArrayFloat * coordinatearray = (Chuck_ArrayFloat *) returnarray;
    for(int i = 0; i < degree; i++)
    {
        API->object->array_float_push_back(coordinatearray, coordinates[i]);
    }  

    // Need to cast back to object due to lost inheirtience structure
    RETURN->v_object = (Chuck_Object*) coordinatearray;
}

CK_DLL_MFUN(all_CoordinateCartesian)
{
    // get our c++ class pointer
    AmbiMath* am_obj = (AmbiMath*)OBJ_MEMBER_INT(SELF, ambimath_data_offset);
    t_CKFLOAT x_ = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT y_ = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT z_ = GET_NEXT_FLOAT(ARGS);
    t_CKINT order = GET_NEXT_INT(ARGS);
    if (!cartesian_test(x_, y_, z_))
    {
        API->vm->throw_exception("Placement Error", "Cartesian coordinates provided do not fall within the unit sphere", nullptr);
        RETURN->v_int = false;
        return;
    }
    int degree = pow((order + 1), 2);
    all(x_, y_, z_, coordinates, order);
    // Create a float[] array
    Chuck_DL_Api::Object returnarray = API->object->create(SHRED, API->type->lookup(VM, "float[]"), false);
    Chuck_ArrayFloat* coordinatearray = (Chuck_ArrayFloat*)returnarray;
    for (int i = 0; i < degree; i++)
    {
        API->object->array_float_push_back(coordinatearray, coordinates[i]);
    }

    // Need to cast back to object due to lost inheirtience structure
    RETURN->v_object = (Chuck_Object*)coordinatearray;
}

CK_DLL_MFUN(x_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = x(direction,elevation);
}

CK_DLL_MFUN(x_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    if (!cartesian_test(x_, y_, z_))
    {
        API->vm->throw_exception("Placement Error", "Cartesian coordinates provided do not fall within the unit sphere", nullptr);
        RETURN->v_int = false;
        return;
    }
    RETURN->v_float = x(x_,y_,z_);
}

CK_DLL_MFUN(y_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = y(direction, elevation);
}

CK_DLL_MFUN(y_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    if (!cartesian_test(x_, y_, z_))
    {
        API->vm->throw_exception("Placement Error", "Cartesian coordinates provided do not fall within the unit sphere", nullptr);
        RETURN->v_int = false;
        return;
    }
    RETURN->v_float = y(x_,y_,z_);
}

CK_DLL_MFUN(z_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = z(direction, elevation);
}

CK_DLL_MFUN(z_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    if (!cartesian_test(x_, y_, z_))
    {
        API->vm->throw_exception("Placement Error", "Cartesian coordinates provided do not fall within the unit sphere", nullptr);
        RETURN->v_int = false;
        return;
    }
    RETURN->v_float = z(x_,y_,z_);
}
