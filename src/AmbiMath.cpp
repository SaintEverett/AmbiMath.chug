//-------------------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-------------------------------------------------------------------------------------
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-------------------------------------------------------------------------------------
// happy chucking & chugging!
//-------------------------------------------------------------------------------------
// hello, this is AmbiMath by Everett M. Carpenter.
// you may need to configure some include paths regarding header files
// if you're looking to build this chugin or make your own flavor (which is encouraged)
//-------------------------------------------------------------------------------------

// include chuck headers
#include "chugin.h"

// general includes
#include "AmbiMath.h"
#include <float.h>
#include <iostream>
#include <limits.h>
#include <math.h>
#include <stdlib.h>

static int w_constant = 1;
static double g_pi = CK_ONE_PI;

// declaration of chugin constructor
CK_DLL_CTOR(ambimath_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(ambimath_dtor);

// example of getter/setter
CK_DLL_MFUN(ambimath_setParam);
CK_DLL_MFUN(ambimath_getParam);

// for chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(ambimath_tick);

// this is a special offset reserved for chugin internal data
t_CKINT ambimath_data_offset = 0;
int mode = 0;

// convert degrees to radians
double degreeRad(float degree)
{
    return (g_pi / 180) * degree;
}
// ambisonic maths
double x(float direction, float elevation)
{
    double x = (cosf(degreeRad(direction)) * cosf(degreeRad(elevation)));
    return x;
}
double x(float x, float y, float z)
{
    return x;
}
double y(float direction, float elevation)
{
    double y = ((sinf(degreeRad(direction))) * (cosf(degreeRad(elevation))));
    return y;
}
double y(float x, float y, float z)
{
    return y;
}
double z(float direction, float elevation)
{
    double z = (sinf(degreeRad(elevation)));
    return z;
}
double z(float x, float y, float z)
{
    return z;
}
double w(float direction, float elevation)
{
    return w_constant;
}
double w(float x, float y, float z)
{
    return w_constant;
}
double r(float direction, float elevation)
{
    double r = (0.5 * (3 * (pow((sinf(degreeRad(elevation))), 2)) - 1));
    return r;
}
double r(float x, float y, float z)
{
    double r = (0.5 * (3 * (pow(z, 2)) - 1));
    return r;
    return r;
}
double s(float direction, float elevation)
{
    double s = (0.8660254038 * (cosf(degreeRad(direction))) * (sinf((2 * degreeRad(elevation)))));
    return s;
}
double s(float x, float y, float z)
{
    double s = (1.732050807568877 * x * z);
    return s;
}
double t(float direction, float elevation)
{
    double t = (0.8660254038 * (sinf(degreeRad(direction))) * (sinf((2 * degreeRad(elevation)))));
    return t;
}
double t(float x, float y, float z)
{
    double t = (1.732050807568877 * y * z);
    return t;
}
double u(float direction, float elevation)
{
    double u = (0.8660254038 * cosf(2 * degreeRad(direction)) * pow(cosf(degreeRad(elevation)), 2));
    return u;
}
double u(float x, float y, float z)
{
    double u = (0.8660254037844386 * (pow(x, 2) - pow(y, 2)));
    return u;
}
double v(float direction, float elevation)
{
    double v = (0.8660254038 * sinf(2 * degreeRad(direction)) * pow(cosf(degreeRad(elevation)), 2));
    return v;
}
double v(float x, float y, float z)
{
    double v = (1.732050807568877 * x * y);
    return v;
}
double l(float direction, float elevation)
{
    double l = (0.6123724357 * cosf(degreeRad(direction)) * cosf(degreeRad(elevation)) * (5 * pow(sinf(degreeRad(elevation)), 2) - 1));
    return l;
}
double l(float x, float y, float z)
{
    double l = (0.6123724356957945 * x * (5 * pow(z, 2) - 1));
    return l;
}
double m(float direction, float elevation)
{
    double m = (0.6123724357 * sinf(degreeRad(direction)) * cosf(degreeRad(elevation)) * (5 * pow(sinf(degreeRad(elevation)), 2) - 1));
    return m;
}
double m(float x, float y, float z)
{
    double m = (0.6123724356957945 * y * (5 * pow(z, 2) - 1));
    return m;
}
double o(float direction, float elevation)
{
    double o = (1.936491673 * sinf(2 * degreeRad(direction)) * sinf(degreeRad(elevation)) * pow(cosf(degreeRad(elevation)), 2));
    return o;
}
double o(float x, float y, float z)
{
    double o = (3.872983346207417 * x * y * z);
    return o;
}
double n(float direction, float elevation)
{
    double n = (1.936491673 * cosf(2 * degreeRad(direction)) * sinf(degreeRad(elevation)) * pow(cosf(degreeRad(elevation)), 2));
    return n;
}
double n(float x, float y, float z)
{
    double n = (1.936491673 * z * (pow(x, 2) - pow(y, 2)));
    return n;
}
double p(float direction, float elevation)
{
    double p = (0.790569415 * cosf(3 * degreeRad(direction)) * pow(cosf(degreeRad(elevation)), 3));
    return p;
}
double p(float x, float y, float z)
{
    double p = (0.790569415 * x * (pow(x, 2) - (3 * pow(y, 2))));
    return p;
}
double q(float direction, float elevation)
{
    double q = (0.790569415 * sinf(3 * degreeRad(direction)) * pow(cosf(degreeRad(elevation)), 3));
    return q;
}
double q(float x, float y, float z)
{
    double q = (0.790569415 * y * ((3 * pow(x, 2)) - pow(y, 2)));
    return q;
}
double k(float direction, float elevation)
{
    double k = (0.5 * sinf(degreeRad(elevation)) * (5 * pow(sinf(degreeRad(elevation)), 2) - 3));
    return k;
}
double k(float x, float y, float z)
{
    double k = (0.5 * z * (5 * pow(z, 2) - 3));
    return k;
}
double hoa4_0(float direction, float elevation)
{
    double coord = (0.739509972887452 * sinf(4 * degreeRad(direction)) * pow(sinf(degreeRad(elevation)), 4));
    return coord;
}
double hoa4_0(float x, float y, float z)
{
    double coord = (2.958039892 * x * y * (pow(x, 2) - pow(y, 2)));
    return coord;
}
double hoa4_1(float direction, float elevation)
{
    double coord = (2.091650066335189 * sinf(3 * degreeRad(direction)) * sinf(degreeRad(elevation)) * pow(cosf(degreeRad(elevation)), 3));
    return coord;
}
double hoa4_1(float x, float y, float z)
{
    double coord = (2.091650066335189 * y * z * ((3 * (pow(x, 2)) - pow(y, 2))));
    return coord;
}
double hoa4_2(float direction, float elevation)
{
    double coord = (0.5590169943749474 * sinf(2 * degreeRad(direction)) * pow(cosf(degreeRad(elevation)), 2) * (7 * pow(sinf(degreeRad(elevation)), 2) - 1));
    return coord;
}
double hoa4_2(float x, float y, float z)
{
    double coord = (1.118033989 * x * y * (7 * pow(z, 2) - 1));
    return coord;
}
double hoa4_3(float direction, float elevation)
{
    double coord = (0.3952847075210474 * sinf(degreeRad(direction)) * sinf(2 * degreeRad(elevation)) * (7 * (pow(sinf(degreeRad(elevation)),2)) - 3));
    return coord;
}
double hoa4_3(float x, float y, float z)
{
    double coord = (0.790569415 * y * z * (7 * pow(z, 2) - 3));
    return coord;
}
double hoa4_4(float direction, float elevation)
{
    double coord = (0.125 * (35 * pow(sinf(degreeRad(elevation)), 4) - 30 * pow(sinf(degreeRad(elevation)), 2) + 3));
    return coord;
}
double hoa4_4(float x, float y, float z)
{
    double coord = (0.125 * (35 * pow(z, 4) - 30 * pow(z, 2) + 3));
    return coord;
}
double hoa4_5(float direction, float elevation)
{
    double coord = (0.3952847075210474 * cosf(degreeRad(direction)) * sinf(2 * degreeRad(elevation)) * (7 * pow(sinf(degreeRad(elevation)), 2) - 3));
    return coord;
}
double hoa4_5(float x, float y, float z)
{
    double coord = (0.790569415 * x * z * (7 * pow(z, 2) - 3));
    return coord;
}
double hoa4_6(float direction, float elevation)
{
    double coord = (0.5590169943749474 * cosf(2 * degreeRad(direction)) * pow(cosf(degreeRad(elevation)), 2) * (7 * pow(sinf(degreeRad(elevation)), 2) - 1));
    return coord;
}
double hoa4_6(float x, float y, float z)
{
    double coord = (0.5590169944 * (pow(x, 2) - pow(y, 2)) * (7 * pow(z, 2) - 1));
    return coord;
}
double hoa4_7(float direction, float elevation)
{
    double coord = (2.091650066335189 * cosf(3 * degreeRad(direction)) * sinf(degreeRad(elevation)) * pow(cosf(degreeRad(elevation)), 3));
    return coord;
}
double hoa4_7(float x, float y, float z)
{
    double coord = (2.091650066335189 * x * z * ((pow(x, 2) - (3 * pow(y, 2)))));
    return coord;
}
double hoa4_8(float direction, float elevation)
{
    double coord = (0.739509972887452 * cosf(4 * degreeRad(direction)) * pow(cosf(degreeRad(elevation)), 4));
    return coord;
}
double hoa4_8(float x, float y, float z)
{
    double coord = (0.739509972887452 * ((pow(x, 4)) - 6 * pow(x, 2) * pow(y, 2) + pow(y, 4)));
    return coord;
}

/*
// array of coordinate function pointers
typedef double (*func_storage) ();
func_storage funcs[] = {w,y,z,x,v,t,r,s,u,q,o,m,k,l,n,p,hoa4_0,hoa4_1,hoa4_2,hoa4_3,hoa4_4,hoa4_5,hoa4_6,hoa4_7,hoa4_8}; // in spherical order
*/

//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class AmbiMath
{
public:
    // constructor
    AmbiMath(t_CKFLOAT fs)
    {
        m_param = 0;
    }

    // for chugins extending UGen
    SAMPLE tick(SAMPLE in)
    {
        // default: this passes whatever input is patched into chugin
        return in;
    }

    // set parameter example
    t_CKFLOAT setParam(t_CKFLOAT p)
    {
        m_param = p;
        return p;
    }

    // get parameter example
    t_CKFLOAT getParam() { return m_param; }

private:
    // instance data
    t_CKFLOAT m_param;
};


//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO(AmbiMath)
{
    // the version string of this chugin, e.g., "v1.2.1"
    QUERY->setinfo(QUERY, CHUGIN_INFO_CHUGIN_VERSION, "v0.0.1 - 'Lanquidity'");
    // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
    QUERY->setinfo(QUERY, CHUGIN_INFO_AUTHORS, "Everett M. Carpenter");
    // text description of this chugin; what is it? what does it do? who is it for?
    QUERY->setinfo(QUERY, CHUGIN_INFO_DESCRIPTION, "AmbiMath calculates cartesian coordinates given an elevation angle and directional angle. As of v0.0.1 'Landquidity', coordinates up to the third order are available.");
    // (optional) URL of the homepage for this chugin
    QUERY->setinfo(QUERY, CHUGIN_INFO_URL, "");
    // (optional) contact email
    QUERY->setinfo(QUERY, CHUGIN_INFO_EMAIL, "");
}


//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY(AmbiMath)
{
    // generally, don't change this...
    QUERY->setname(QUERY, "AmbiMath");

    // ------------------------------------------------------------------------
    // begin class definition(s); will be compiled, verified,
    // and added to the chuck host type system for use
    // ------------------------------------------------------------------------
    // NOTE to create a non-UGen class, change the second argument
    // to extend a different ChucK class (e.g., "Object")
    QUERY->begin_class(QUERY, "AmbiMath", "Object");
    QUERY->doc_class(QUERY, "Math required for Ambisonics");

    // register default constructor
    QUERY->add_ctor(QUERY, ambimath_ctor);
    // NOTE constructors can be overloaded like any other functions,
    // each overloaded constructor begins with `QUERY->add_ctor()`
    // followed by a sequence of `QUERY->add_arg()`

    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, ambimath_dtor);

    // for UGens only: add tick function
    // NOTE a non-UGen class should remove or comment out this next line
    // QUERY->add_ugen_func( QUERY, ambimath_tick, NULL, 1, 1 );
    // NOTE: if this is to be a UGen with more than 1 channel,
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function usinfg CK_DLL_TICKF  
    // function definition

    // x coordinate(polar)
    QUERY->add_mfun(QUERY, x_CoordinatePolar, "float", "x");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian X coordinate given elevation and direction angles");

    // x coordinate(cartesian)
    QUERY->add_mfun(QUERY, x_CoordinateCartesian, "float", "x");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian X coordinate given x,y,z");

    // y coodinate(polar)
    QUERY->add_mfun(QUERY, y_CoordinatePolar, "float", "y");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian Y coordinate given elevation and direction angles");

    // y coordinate(cartesian)
    QUERY->add_mfun(QUERY, y_CoordinateCartesian, "float", "y");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian Y coordinate given x,y,z");

    // z coordinate(polar)
    QUERY->add_mfun(QUERY, z_CoordinatePolar, "float", "z");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian Z coordinate given elevation and direction angles");

    // z coordinate(cartesian)
    QUERY->add_mfun(QUERY, z_CoordinateCartesian, "float", "z");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian Z coordinate given x,y,z");

    // r coordinate(polar)
    QUERY->add_mfun(QUERY, r_CoordinatePolar, "float", "r");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian R coordinate given elevation and direction angles");

    // r coordinate(cartesian)
    QUERY->add_mfun(QUERY, r_CoordinateCartesian, "float", "r");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian R coordinate given x,y,z");

    // s coordinate(polar)
    QUERY->add_mfun(QUERY, s_CoordinatePolar, "float", "s");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian S coordinate given elevation and direction angles");

    // s coordinate(cartesian)
    QUERY->add_mfun(QUERY, s_CoordinateCartesian, "float", "s");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian S coordinate given x,y,z");

    // t coordinate(polar)
    QUERY->add_mfun(QUERY, t_CoordinatePolar, "float", "t");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian T coordinate given elevation and direction angles");

    // t coordinate(cartesian)
    QUERY->add_mfun(QUERY, t_CoordinateCartesian, "float", "t");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian T coordinate given x,y,z");

    // u coordinate(polar)
    QUERY->add_mfun(QUERY, u_CoordinatePolar, "float", "u");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian U coordinate given elevation and direction angles");

    // u coordinate(cartesian)
    QUERY->add_mfun(QUERY, u_CoordinateCartesian, "float", "u");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian U coordinate given x,y,z");

    // v coordinate(polar)
    QUERY->add_mfun(QUERY, v_CoordinatePolar, "float", "v");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian V coordinate given elevation and direction angles");

    // r coordinate(cartesian)
    QUERY->add_mfun(QUERY, v_CoordinateCartesian, "float", "v");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian V coordinate given x,y,z");

    // l coordinate(polar)
    QUERY->add_mfun(QUERY, l_CoordinatePolar, "float", "l");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian L coordinate given elevation and direction angles");

    // l coordinate(cartesian)
    QUERY->add_mfun(QUERY, l_CoordinateCartesian, "float", "l");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian L coordinate given x,y,z");

    // m coordinate(polar)
    QUERY->add_mfun(QUERY, m_CoordinatePolar, "float", "m");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian M coordinate given elevation and direction angles");

    // m coordinate(cartesian)
    QUERY->add_mfun(QUERY, m_CoordinateCartesian, "float", "m");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian M coordinate given x,y,z");

    // n coordinate(polar)
    QUERY->add_mfun(QUERY, n_CoordinatePolar, "float", "n");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian N coordinate given elevation and direction angles");

    // n coordinate(cartesian)
    QUERY->add_mfun(QUERY, n_CoordinateCartesian, "float", "n");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian N coordinate given x,y,z");

    // o coordinate(polar)
    QUERY->add_mfun(QUERY, o_CoordinatePolar, "float", "o");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian O coordinate given elevation and direction angles");

    // o coordinate(cartesian)
    QUERY->add_mfun(QUERY, o_CoordinateCartesian, "float", "o");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian O coordinate given x,y,z");

    // p coordinate(polar)
    QUERY->add_mfun(QUERY, p_CoordinatePolar, "float", "p");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian P coordinate given elevation and direction angles");

    // p coordinate(cartesian)
    QUERY->add_mfun(QUERY, p_CoordinateCartesian, "float", "p");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian P coordinate given x,y,z");

    // q coordinate(polar)
    QUERY->add_mfun(QUERY, q_CoordinatePolar, "float", "q");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian Q coordinate given elevation and direction angles");

    // q coordinate(cartesian)
    QUERY->add_mfun(QUERY, q_CoordinateCartesian, "float", "q");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian Q coordinate given x,y,z");

    // k coordinate(polar)
    QUERY->add_mfun(QUERY, k_CoordinatePolar, "float", "k");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian K coordinate given elevation and direction angles");

    // k coordinate(cartesian)
    QUERY->add_mfun(QUERY, k_CoordinateCartesian, "float", "k");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->doc_func(QUERY, "Computes cartesian K coordinate given x,y,z");

    // all coordinates
    QUERY->add_mfun(QUERY, all_CoordinatePolar, "void", "all");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->add_arg(QUERY, "float[]", "coordinates");
    QUERY->add_arg(QUERY, "int", "order");
    QUERY->doc_func(QUERY, "Computes all coordinates of a given order and returns an array of the corresponding size. Order of coordinates is X,Y,Z,W,V,T,R,S,U,Q,O,M,K,L,N,O.");

    // all coordinates
    QUERY->add_mfun(QUERY, all_CoordinateCartesian, "void", "all");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "z");
    QUERY->add_arg(QUERY, "float[]", "coordinates");
    QUERY->add_arg(QUERY, "int", "order");
    QUERY->doc_func(QUERY, "Computes all coordinates of a given order and returns an array of the corresponding size. Order of coordinates is X,Y,Z,W,V,T,R,S,U,Q,O,M,K,L,N,O.");

    // create and set w constant
    QUERY->add_svar(QUERY, "float", "w", TRUE, &w_constant);
    QUERY->doc_var(QUERY, "W constant used in SN3D Ambisonics");

    // example of adding setter method
    QUERY->add_mfun(QUERY, ambimath_setParam, "float", "param");
    // example of adding argument to the above method
    QUERY->add_arg(QUERY, "float", "arg");

    // example of adding getter method
    QUERY->add_mfun(QUERY, ambimath_getParam, "float", "param");

    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    ambimath_data_offset = QUERY->add_mvar(QUERY, "int", "@am_data", false);

    // ------------------------------------------------------------------------
    // end the class definition
    // IMPORTANT: this MUST be called to each class definition!
    // ------------------------------------------------------------------------
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the default constructor
CK_DLL_CTOR(ambimath_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, ambimath_data_offset) = 0;

    // instantiate our internal c++ class representation
    AmbiMath* am_obj = new AmbiMath(API->vm->srate(VM));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, ambimath_data_offset) = (t_CKINT)am_obj;
}


// implementation for the destructor
CK_DLL_DTOR(ambimath_dtor)
{
    // get our c++ class pointer
    AmbiMath* am_obj = (AmbiMath*)OBJ_MEMBER_INT(SELF, ambimath_data_offset);
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE(am_obj);
    // set the data field to 0
    OBJ_MEMBER_INT(SELF, ambimath_data_offset) = 0;
}

// example implementation for setter
CK_DLL_MFUN(ambimath_setParam)
{
    // get our c++ class pointer
    AmbiMath* am_obj = (AmbiMath*)OBJ_MEMBER_INT(SELF, ambimath_data_offset);

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT(ARGS);

    // call setParam() and set the return value
    RETURN->v_float = am_obj->setParam(arg1);
}

// example implementation for getter
CK_DLL_MFUN(ambimath_getParam)
{
    // get our c++ class pointer
    AmbiMath* am_obj = (AmbiMath*)OBJ_MEMBER_INT(SELF, ambimath_data_offset);

    // call getParam() and set the return value
    RETURN->v_float = am_obj->getParam();
}

CK_DLL_MFUN(all_CoordinatePolar)
{
    t_CKFLOAT direction = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT elevation = GET_NEXT_FLOAT(ARGS);
    Chuck_ArrayFloat* coordinates = (Chuck_ArrayFloat*)GET_NEXT_OBJECT(ARGS);
    t_CKINT order = GET_NEXT_INT(ARGS);
    int size = (API->object->array_float_size(coordinates));
    int num_speakers = pow((order + 1), 2);
    if (size >= num_speakers)
    {
        if (order == 1)
        {
            API->object->array_float_set_idx(coordinates, 0, w(direction, elevation));
            API->object->array_float_set_idx(coordinates, 1, y(direction, elevation));
            API->object->array_float_set_idx(coordinates, 2, z(direction, elevation));
            API->object->array_float_set_idx(coordinates, 3, x(direction, elevation));
        }
        else if (order == 2)
        {
            API->object->array_float_set_idx(coordinates, 0, w(direction, elevation));
            API->object->array_float_set_idx(coordinates, 1, y(direction, elevation));
            API->object->array_float_set_idx(coordinates, 2, z(direction, elevation));
            API->object->array_float_set_idx(coordinates, 3, x(direction, elevation));
            API->object->array_float_set_idx(coordinates, 4, v(direction, elevation));
            API->object->array_float_set_idx(coordinates, 5, t(direction, elevation));
            API->object->array_float_set_idx(coordinates, 6, r(direction, elevation));
            API->object->array_float_set_idx(coordinates, 7, s(direction, elevation));
            API->object->array_float_set_idx(coordinates, 8, u(direction, elevation));
        }
        else if (order == 3)
        {
            API->object->array_float_set_idx(coordinates, 0, w(direction, elevation));
            API->object->array_float_set_idx(coordinates, 1, y(direction, elevation));
            API->object->array_float_set_idx(coordinates, 2, z(direction, elevation));
            API->object->array_float_set_idx(coordinates, 3, x(direction, elevation));
            API->object->array_float_set_idx(coordinates, 4, v(direction, elevation));
            API->object->array_float_set_idx(coordinates, 5, t(direction, elevation));
            API->object->array_float_set_idx(coordinates, 6, r(direction, elevation));
            API->object->array_float_set_idx(coordinates, 7, s(direction, elevation));
            API->object->array_float_set_idx(coordinates, 8, u(direction, elevation));
            API->object->array_float_set_idx(coordinates, 9, q(direction, elevation));
            API->object->array_float_set_idx(coordinates, 10, o(direction, elevation));
            API->object->array_float_set_idx(coordinates, 11, m(direction, elevation));
            API->object->array_float_set_idx(coordinates, 12, k(direction, elevation));
            API->object->array_float_set_idx(coordinates, 13, l(direction, elevation));
            API->object->array_float_set_idx(coordinates, 14, n(direction, elevation));
            API->object->array_float_set_idx(coordinates, 15, p(direction, elevation));
        }
        else if (order == 4)
        {
            API->object->array_float_set_idx(coordinates, 0, w(direction, elevation));
            API->object->array_float_set_idx(coordinates, 1, y(direction, elevation));
            API->object->array_float_set_idx(coordinates, 2, z(direction, elevation));
            API->object->array_float_set_idx(coordinates, 3, x(direction, elevation));
            API->object->array_float_set_idx(coordinates, 4, v(direction, elevation));
            API->object->array_float_set_idx(coordinates, 5, t(direction, elevation));
            API->object->array_float_set_idx(coordinates, 6, r(direction, elevation));
            API->object->array_float_set_idx(coordinates, 7, s(direction, elevation));
            API->object->array_float_set_idx(coordinates, 8, u(direction, elevation));
            API->object->array_float_set_idx(coordinates, 9, q(direction, elevation));
            API->object->array_float_set_idx(coordinates, 10, o(direction, elevation));
            API->object->array_float_set_idx(coordinates, 11, m(direction, elevation));
            API->object->array_float_set_idx(coordinates, 12, k(direction, elevation));
            API->object->array_float_set_idx(coordinates, 13, l(direction, elevation));
            API->object->array_float_set_idx(coordinates, 14, n(direction, elevation));
            API->object->array_float_set_idx(coordinates, 15, p(direction, elevation));
            API->object->array_float_set_idx(coordinates, 16, hoa4_0(direction, elevation));
            API->object->array_float_set_idx(coordinates, 17, hoa4_1(direction, elevation));
            API->object->array_float_set_idx(coordinates, 18, hoa4_2(direction, elevation));
            API->object->array_float_set_idx(coordinates, 19, hoa4_3(direction, elevation));
            API->object->array_float_set_idx(coordinates, 20, hoa4_4(direction, elevation));
            API->object->array_float_set_idx(coordinates, 21, hoa4_5(direction, elevation));
            API->object->array_float_set_idx(coordinates, 22, hoa4_6(direction, elevation));
            API->object->array_float_set_idx(coordinates, 23, hoa4_7(direction, elevation));
            API->object->array_float_set_idx(coordinates, 24, hoa4_8(direction, elevation));
        }
    }
}

CK_DLL_MFUN(all_CoordinateCartesian)
{
    t_CKFLOAT x_ = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT y_ = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT z_ = GET_NEXT_FLOAT(ARGS);
    Chuck_ArrayFloat* coordinates = (Chuck_ArrayFloat*)GET_NEXT_OBJECT(ARGS);
    t_CKINT order = GET_NEXT_INT(ARGS);
    int size = (API->object->array_float_size(coordinates));
    int num_speakers = pow((order + 1), 2);
    if (size >= num_speakers)
    {
        if (order == 1)
        {
            API->object->array_float_set_idx(coordinates, 0, w(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 1, y(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 2, z(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 3, x(x_, y_, z_));
        }
        else if (order == 2)
        {
            API->object->array_float_set_idx(coordinates, 0, w(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 1, y(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 2, z(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 3, x(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 4, v(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 5, t(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 6, r(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 7, s(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 8, u(x_, y_, z_));
        }
        else if (order == 3)
        {
            API->object->array_float_set_idx(coordinates, 0, w(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 1, y(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 2, z(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 3, x(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 4, v(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 5, t(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 6, r(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 7, s(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 8, u(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 9, q(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 10, o(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 11, m(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 12, k(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 13, l(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 14, n(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 15, p(x_, y_, z_));
        }
        else if (order == 4)
        {
            API->object->array_float_set_idx(coordinates, 0, w(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 1, y(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 2, z(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 3, x(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 4, v(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 5, t(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 6, r(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 7, s(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 8, u(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 9, q(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 10, o(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 11, m(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 12, k(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 13, l(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 14, n(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 15, p(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 16, hoa4_0(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 17, hoa4_1(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 18, hoa4_2(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 19, hoa4_3(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 20, hoa4_4(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 21, hoa4_5(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 22, hoa4_6(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 23, hoa4_7(x_, y_, z_));
            API->object->array_float_set_idx(coordinates, 24, hoa4_8(x_, y_, z_));
        }
    }
}

CK_DLL_MFUN(x_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = x(direction,elevation);
}

CK_DLL_MFUN(x_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = x(x_,y_,z_);
}

CK_DLL_MFUN(y_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = y(direction, elevation);
}

CK_DLL_MFUN(y_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = y(x_,y_,z_);
}

CK_DLL_MFUN(z_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = z(direction, elevation);
}

CK_DLL_MFUN(z_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = z(x_,y_,z_);
}

CK_DLL_MFUN(r_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = r(direction, elevation);
}

CK_DLL_MFUN(r_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = r(x_,y_,z_);
}

CK_DLL_MFUN(s_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = s(direction, elevation);
}

CK_DLL_MFUN(s_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = s(x_,y_,z_);
}

CK_DLL_MFUN(t_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = t(direction, elevation);
}

CK_DLL_MFUN(t_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = t(x_,y_,z_);
}

CK_DLL_MFUN(u_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = u(direction, elevation);
}

CK_DLL_MFUN(u_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = u(x_,y_,z_);
}

CK_DLL_MFUN(v_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = v(direction, elevation);
}

CK_DLL_MFUN(v_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = v(x_,y_,z_);
}

CK_DLL_MFUN(l_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = l(direction, elevation);
}

CK_DLL_MFUN(l_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = l(x_,y_,z_);
}

CK_DLL_MFUN(m_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = m(direction, elevation);
}

CK_DLL_MFUN(m_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = m(x_,y_,z_);
}

CK_DLL_MFUN(o_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = o(direction, elevation);
}

CK_DLL_MFUN(o_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = o(x_,y_,z_);
}

CK_DLL_MFUN(n_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = n(direction, elevation);
}

CK_DLL_MFUN(n_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = n(x_,y_,z_);
}

CK_DLL_MFUN(p_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = p(direction, elevation);
}

CK_DLL_MFUN(p_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = p(x_,y_,z_);
}

CK_DLL_MFUN(q_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = q(direction, elevation);
}

CK_DLL_MFUN(q_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = q(x_,y_,z_);
}

CK_DLL_MFUN(k_CoordinatePolar)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = k(direction, elevation);
}

CK_DLL_MFUN(k_CoordinateCartesian)
{
    float x_ = GET_NEXT_FLOAT(ARGS);
    float y_ = GET_NEXT_FLOAT(ARGS);
    float z_ = GET_NEXT_FLOAT(ARGS);
    RETURN->v_float = k(x_,y_,z_);
}

/*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Consider in developing the all coordinate function...
* In the chugin.h file, line 2189, there is a block of code for determining the size of a float array inside ChucK.
* There are also details on retrieving float array members with a given index.
* As well as details on setting a float array member with a given index.
* Perhaps the arguments can give the needed array name or pointer, and a for loop can replace each array member.
* Make sure to check if the array size lines up with the amount of coordinates given the order.
* You can also clear an array in this code section, perhaps it's best to clear the given array and then proceed with filling it.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*/
